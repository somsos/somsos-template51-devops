name: template51

networks:
  net51:
    driver: bridge
    ipam:
      config:
        - subnet: 172.30.0.0/24
          gateway: 172.30.0.1

volumes:
  data_postgres:




services:


  reverse-proxy:
    image: nginxproxy/nginx-proxy
    container_name: reverse-proxy
    ports:
      - "80:80"
      - "443:443"
    volumes:
      - /var/run/docker.sock:/tmp/docker.sock:ro
      - ./data/reverse-proxy/certs:/etc/nginx/certs:rw
      - ./data/reverse-proxy/vhost.d:/etc/nginx/vhost.d
      - ./data/reverse-proxy/html:/usr/share/nginx/html
    networks:
      net51:
        ipv4_address: ${REVERSE_PROXY_IP}


# for automatic SSL certificate management
# IMPORTANT: run it at the end: 
  acme-companion:
    image: nginxproxy/acme-companion
    container_name: acme-companion
    depends_on:
      - reverse-proxy
    environment:
      - DEFAULT_EMAIL=${MY_EMAIL}
      - NGINX_PROXY_CONTAINER=reverse-proxy
    volumes:
      - /var/run/docker.sock:/var/run/docker.sock:ro
      - ./data/reverse-proxy/certs:/etc/nginx/certs:rw
      - ./data/reverse-proxy/vhost.d:/etc/nginx/vhost.d
      - ./data/reverse-proxy/html:/usr/share/nginx/html
      - ./data/reverse-proxy/acme:/etc/acme.sh
    networks:
      net51:
        ipv4_address: ${ACME_COMPANION_IP}

  db:
    container_name: ${DB_SERVICE_NAME}
    image: postgres:17.6-alpine3.22
    command: ["postgres", "-c", "log_statement=all"]
    networks:
      net51:
        ipv4_address: ${DB_IP}
    ports:
      - "${DB_PORT}:5432"
    volumes:
      - data_postgres:/var/lib/postgresql/data
    environment:
      - POSTGRES_DB=${POSTGRES_DB}
      - POSTGRES_USER=${POSTGRES_USER}
      - POSTGRES_PASSWORD=${DB_PASSWORD}
    healthcheck:
      test: ["CMD-SHELL", "PGDATABASE=${POSTGRES_DB} pg_isready -U ${POSTGRES_USER} -h localhost"]
      interval: 20s
      timeout: 5s
      retries: 5


# VERY IMPORTANT: Run the migrations service using the flag --no-deps to avoid recreating the db container again
# which can erase the data if the volume is not set correctly.

# run with: "docker compose run --rm --no-deps db_migrate deploy" for deploy
# or use "docker compose run --rm --no-deps db_migrate rollback" for rollback
  db_migrate:
    build: ${DB_MIGRATIONS_DIR}
    image: db_migrate:v01
    container_name: db_migrate
    entrypoint: [ "sh", "./docker-entrypoint.sh" ]
    depends_on:
      db:
        condition: service_healthy
    environment:
      - DB_NAME=${POSTGRES_DB}
      - DB_USER=${POSTGRES_USER}
      - DB_PASSWORD=${DB_PASSWORD}
      - DB_IP=${DB_IP}
      - DB_PORT=${DB_PORT}
    networks:
      - net51
    restart: "no"


  # run it manually with: "BUILD_NUMBER=1 docker compose run --rm --no-deps db_backup"
  db_backup:
    container_name: db_backup
    build:
      context: ./utils
      dockerfile: alpine-utils.dockerfile
    image: utils:1
    environment:
      - PGPASSWORD=${DB_PASSWORD}
      - BUILD_NUMBER=${BUILD_NUMBER}
    volumes:
      - ./data/db_backups:/app/backups/
    entrypoint: [ "bash", "-c", "pg_dump -h ${DB_IP} -U ${POSTGRES_USER} -d ${POSTGRES_DB} -F p > /app/backups/db_backup_$(echo $BUILD_NUMBER)_$(date +'%Y-%m-%d_%H-%M-%S').sql" ]
    networks:
      - net51
    depends_on:
      db:
        condition: service_healthy
    restart: "no"



  # run it manually with: "BACKUP_NAME=1 docker compose run --rm --no-deps db_backup"
  db_restore:
    container_name: db_restore
    build:
      context: ./utils
      dockerfile: alpine-utils.dockerfile
    image: utils:1
    environment:
      - PGPASSWORD=${DB_PASSWORD}
      - BACKUP_NAME=${BACKUP_NAME}
    volumes:
      - ./data/db_backups:/app/backups/:ro
    working_dir: /app/backups
    entrypoint: [ "bash", "-c", "psql -U ${POSTGRES_USER} -d ${POSTGRES_DB} < ./${BACKUP_NAME}" ]
    networks:
      - net51
    depends_on:
      db:
        condition: service_healthy
    restart: "no"

  back:
    container_name: ${BACK_SERVICE_NAME}
    build: ./back
    image: ${BACK_IMAGE_NAME}
    expose:
      - "8080"
    environment:
      - VIRTUAL_HOST=api.${MY_DOMAIN}
      - LETSENCRYPT_HOST=api.${MY_DOMAIN}
      - LETSENCRYPT_EMAIL=${MY_EMAIL}
      - VIRTUAL_PORT=8080
    networks:
      net51:
        ipv4_address: ${BACK_IP}
    extra_hosts:
      - "mariomv.duckdns.org:host-gateway" # to connect to db
    depends_on:
      db_migrate:
        condition: service_completed_successfully
    healthcheck:
      test: ["CMD-SHELL", "wget --spider -q http://localhost:8080/actuator/health && echo servicesAlive"]
      interval: 20s
      retries: 5



  front:
    container_name: ${FRONT_SERVICE_NAME}
    build: ./front
    image: ${FRONT_IMAGE_NAME}
    expose:
      - "80"
    environment:
      - VIRTUAL_HOST=${MY_DOMAIN}
      - LETSENCRYPT_HOST=${MY_DOMAIN}
      - LETSENCRYPT_EMAIL=${MY_EMAIL}
      - VIRTUAL_PORT=80
    networks:
      net51:
        ipv4_address: ${FRONT_IP}
    extra_hosts:
      - "api.mariomv.duckdns.org:host-gateway"
    depends_on:
      back:
        condition: service_healthy
    healthcheck:
      test: ["CMD-SHELL", "wget --spider -q http://127.0.0.1 && echo servicesAlive"]
      interval: 20s
      retries: 5



  gitea:
    container_name: gitea
    image: docker.gitea.com/gitea:1.23.8
    environment:
      - USER_UID=1000
      - USER_GID=1000
      - VIRTUAL_HOST=gitea.${MY_DOMAIN}
      - VIRTUAL_PORT=3000
      - LETSENCRYPT_HOST=gitea.${MY_DOMAIN}
      - LETSENCRYPT_EMAIL=${MY_EMAIL}
    volumes:
      - ./data/gitea:/data
      - /etc/timezone:/etc/timezone:ro
      - /etc/localtime:/etc/localtime:ro
    ports:
      - "222:22"
    expose:
      - "3000"
    networks:
      net51:
        ipv4_address: ${GITEA_IP}
    extra_hosts:
      - "jenkins.mariomv.duckdns.org:host-gateway"





  #CAREFUL: Might give file permissions error if does run: "sudo chown -R 1000:1000 ./data_jenkins"
  jenkins:
    container_name: jenkins
    build:
      context: .
      dockerfile: jenkins-with-docker.dockerfile
    privileged: true
    environment:
      - JENKINS_JAVA_OPTS="-Dhudson.model.ParametersAction.keepUndefinedParameters=false"
      - VIRTUAL_HOST=jenkins.${MY_DOMAIN}
      - LETSENCRYPT_HOST=jenkins.${MY_DOMAIN}
      - LETSENCRYPT_EMAIL=${MY_EMAIL}
      - VIRTUAL_PORT=8080
    expose:
      - "8080"
    volumes:
# main folder where it wil be all the generated content of jenkins
      - ./data/jenkins:/var/jenkins_home
# We give access to docker host to jenkins container and sync time
      - ./data/secrets/ssh/:/var/jenkins_home/.ssh:ro
      - /var/run/docker.sock:/var/run/docker.sock
      - /usr/bin/docker:/usr/local/bin/docker
      - /etc/timezone:/etc/timezone:ro
      - /etc/localtime:/etc/localtime:ro
    networks:
      net51:
        ipv4_address: ${JENKINS_IP}
    extra_hosts:
      - "gitea.mariomv.duckdns.org:host-gateway"


# ■■■■■■■■■■■■■■■■■■■■■■■■■■■- artt -■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■

  artt_db_dev:
    image: postgres:14-alpine3.22.1
    container_name: artt_db_dev
    volumes:
      - ./data/artt/data/postgresql_dev:/var/lib/postgresql/data
    expose:
      - 5432
    environment:
      POSTGRES_DB: ${DB_NAME}
      POSTGRES_USER: ${DB_USER}
      POSTGRES_PASSWORD: ${DB_PASS}
    networks:
      net51:
        ipv4_address: ${DB_HOST}



# docker run -ti --rm --name test -w /dist -v ./data/artt:/dist --network template51_net51 alpine:3.22.1 sh

  artt_server_dev:
    image: alpine:3.22.1
    container_name: artt_server_dev
    environment:
      - VIRTUAL_HOST=artesaniastlaxco.duckdns.org
      - VIRTUAL_PORT=${PORT}
      - LETSENCRYPT_HOST=artesaniastlaxco.duckdns.org
      - LETSENCRYPT_EMAIL=${MY_EMAIL}
    depends_on:
      - artt_db_dev
    working_dir: /dist
    volumes:
      - ./data/artt:/dist
    command: ["./artt_server.exe"]
    expose:
      - ${PORT}
    networks:
      net51:
        ipv4_address: 172.30.0.71
